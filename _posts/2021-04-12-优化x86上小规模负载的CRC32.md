---
layout: post
title:  "[翻译] 优化x86上小规模负载的CRC32"
date:   2021-04-20 9:36:00 +0800
author: xiewajueji
tags: CRC32 x86 Translation
---
这位作者是游戏机硬件爱好者，业余时间从事游戏机模拟器的开发，[本文](https://merrymage.com/lab/crc32/)是针对小规模的CRC32的优化内容

----

最近在一组夜班中，我疲惫的头脑想了解如何通过无进位乘法运算来实现CRC32。这似乎是出于以下几种想法:

1. x86支持**pclmulqdq**指令，实现64bit * 64bit -> 127bit的无进位乘法
2. 尽管x86有针对Castagnoli多项式0x1EDC6F41的SSE4.2的**crc32c**指令，但是它好像没有针对其他多项式的类似的指令
3. AArch64系统提供了一个使用ISO/ANSI/gzip/PNG多项式0x04C11DB7的CRC32指令
4. 现在的AArch64模拟器回退到缓慢的软件实现当遇到了上述提到的指令

我对CRC32有一个模糊的理解，所以我知道这是这是可能的，但是当时的理解不足以使实现变得显而易见。回想起来，该解决方案应该是显而易见的，但是我还是在为了后人记录一下。

## 需求实施
主要动机是重新实现AArch64架构下的crc32指令集，因此让我们简单看下它们。它们是一系列针对小负载的指令:

{% highlight assembly linenos %}
CRC32B <Wd>, <Wn>, <Wm>
CRC32H <Wd>, <Wn>, <Wm>
CRC32W <Wd>, <Wn>, <Wm>
CRC32X <Wd>, <Wn>, <Xm>
{% endhighlight %}

针对所有的这些指令，n寄存器是累计的crc32值，m寄存器是当前的输入值。可以在[AArch manual](https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile)查看这些指令的ASL实现:

{% highlight c linenos %}
bits(32)    acc  = X[n]; // accumulator
bits(size)  val  = X[m]; // input value
bits(32)    poly = 0x04C11DB7;

bits(32+size) tempacc = BitReverse(acc):Zeros(size);
bits(size+32) tempval = BitReverse(val):Zeros(32);

// Poly32Mod2 on a bitstring does a polynomial Modulus over {0, 1} operation
X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));
{% endhighlight %}

从上面我们能看出我们需要实现8,16,32和64位负载的crc32。